// Code generated
// This file is a generated precompile contract test with the skeleton of test functions.
// The file is generated by a template. Please inspect every code and comment in this file before use.

package bls

import (
	"math/big"
	"testing"

	"github.com/ava-labs/avalanchego/utils/crypto/bls"
	"github.com/ava-labs/subnet-evm/core/state"
	"github.com/ava-labs/subnet-evm/precompile/testutils"
	"github.com/ava-labs/subnet-evm/vmerrs"
	"github.com/ethereum/go-ethereum/common"
	"github.com/stretchr/testify/require"
)

var (
	_ = vmerrs.ErrOutOfGas
	_ = big.NewInt
	_ = common.Big0
	_ = require.New
)

// These tests are run against the precompile contract directly with
// the given input and expected output. They're just a guide to
// help you write your own tests. These tests are for general cases like
// allowlist, readOnly behaviour, and gas cost. You should write your own
// tests for specific cases.
var (
	tests = map[string]testutils.PrecompileTest{
		"insufficient gas for verifyBLSSignature should fail": {
			Caller: common.Address{1},
			InputFn: func(t testing.TB) []byte {
				// CUSTOM CODE STARTS HERE
				// populate test input here
				testInput := VerifyBLSSignatureInput{
					Message:   "test message",
                    Signature: []byte{0x01, 0x02, 0x03}, // Example signature bytes
                    PublicKey: []byte{0x04, 0x05, 0x06}, // Example public key bytes
				}
				input, err := PackVerifyBLSSignature(testInput)
				require.NoError(t, err)
				return input
			},
			SuppliedGas: VerifyBLSSignatureGasCost - 1,
			ReadOnly:    false,
			ExpectedErr: vmerrs.ErrOutOfGas.Error(),
		},
		"invalid signature should fail verification": {
            Caller: common.Address{1},
            InputFn: func(t testing.TB) []byte {
                sk, err := bls.NewSecretKey()
                require.NoError(t, err)
                pk := bls.PublicFromSecretKey(sk)
                message := []byte("test message")
                sig := bls.Sign(sk, []byte("different message"))

                testInput := VerifyBLSSignatureInput{
                    Message:   string(message),
                    Signature: bls.SignatureToBytes(sig),
                    PublicKey: bls.PublicKeyToCompressedBytes(pk),
                }
                input, err := PackVerifyBLSSignature(testInput)
                require.NoError(t, err)
                return input
            },
            SuppliedGas: VerifyBLSSignatureGasCost,
            ReadOnly:    false,
            ExpectedRes: common.Hex2Bytes("0000000000000000000000000000000000000000000000000000000000000000"),
        },
		"valid signature should verify successfully": {
			Caller: common.Address{1},
			InputFn: func(t testing.TB) []byte {
				privateKey, err := bls.NewSecretKey()
				require.NoError(t, err)
				publicKey := bls.PublicFromSecretKey(privateKey)
				message := []byte("test message")
				signature := bls.Sign(privateKey, message)

				testInput := VerifyBLSSignatureInput{
					Message:   string(message),
					Signature: bls.SignatureToBytes(signature),
					PublicKey: bls.PublicKeyToCompressedBytes(publicKey),
				}
				input, err := PackVerifyBLSSignature(testInput)
				require.NoError(t, err)
				return input
			},
			SuppliedGas: VerifyBLSSignatureGasCost,
			ReadOnly:    false,
			ExpectedRes: common.Hex2Bytes("0000000000000000000000000000000000000000000000000000000000000001"), // Assuming true is represented as 32 bytes with the last byte as 1
			ExpectedErr: "",
		},
		"invalid public key should fail": {
            Caller: common.Address{1},
            InputFn: func(t testing.TB) []byte {
                sk, err := bls.NewSecretKey()
                require.NoError(t, err)
                message := []byte("test message")
                sig := bls.Sign(sk, message)

                testInput := VerifyBLSSignatureInput{
                    Message:   string(message),
                    Signature: bls.SignatureToBytes(sig),
                    PublicKey: make([]byte, bls.PublicKeyLen),
                }
                input, err := PackVerifyBLSSignature(testInput)
                require.NoError(t, err)
                return input
            },
            SuppliedGas: VerifyBLSSignatureGasCost,
            ReadOnly:    false,
            ExpectedErr: "invalid public key",
        },
		"empty message should be handled": {
            Caller: common.Address{1},
            InputFn: func(t testing.TB) []byte {
                sk, err := bls.NewSecretKey()
                require.NoError(t, err)
                pk := bls.PublicFromSecretKey(sk)
                message := []byte{}
                sig := bls.Sign(sk, message)

                testInput := VerifyBLSSignatureInput{
                    Message:   string(message),
                    Signature: bls.SignatureToBytes(sig),
                    PublicKey: bls.PublicKeyToCompressedBytes(pk),
                }
                input, err := PackVerifyBLSSignature(testInput)
                require.NoError(t, err)
                return input
            },
            SuppliedGas: VerifyBLSSignatureGasCost,
            ReadOnly:    false,
            ExpectedRes: common.Hex2Bytes("0000000000000000000000000000000000000000000000000000000000000001"),
        },
	}
)

// TestBlsRun tests the Run function of the precompile contract.

// func TestBlsRun(t *testing.T) {
// 	// Run tests.
// 	for name, test := range tests {
// 		t.Run(name, func(t *testing.T) {
// 			test.Run(t, Module, state.NewTestStateDB(t))
// 		})
// 	}
// 	// Fuzz testing
//     N := 1000 // Number of fuzz tests to run

//     for i := 0; i < N; i++ {
//         t.Run("Fuzz test", func(t *testing.T) {
//             // Generate random inputs
//             sk, err := bls.NewSecretKey()
//             require.NoError(t, err)
//             pk := bls.PublicFromSecretKey(sk)

//             // Use a deterministic but varying message
//             message := []byte("test message " + string(byte(i%256)))

//             // Sometimes use a different message for signing to test invalid signatures
//             signMessage := message
//             if i%5 == 0 { // 20% chance of invalid signature
//                 signMessage = []byte("different message")
//             }

//             sig := bls.Sign(sk, signMessage)

//             testInput := VerifyBLSSignatureInput{
//                 Message:   string(message),
//                 Signature: bls.SignatureToBytes(sig),
//                 PublicKey: bls.PublicKeyToCompressedBytes(pk),
//             }
//             input, err := PackVerifyBLSSignature(testInput)
//             require.NoError(t, err)

//             // Expected result
//             expectedRes := common.Hex2Bytes("0000000000000000000000000000000000000000000000000000000000000001")
//             if i%5 == 0 {
//                 expectedRes = common.Hex2Bytes("0000000000000000000000000000000000000000000000000000000000000000")
//             }

//             fuzzTest := testutils.PrecompileTest{
//                 Caller:      common.Address{1},
//                 Input:       input,
//                 SuppliedGas: VerifyBLSSignatureGasCost,
//                 ReadOnly:    false,
//                 ExpectedRes: expectedRes,
//             }

//             fuzzTest.Run(t, Module, state.NewTestStateDB(t))
//         })
//     }
// }

func BenchmarkBls(b *testing.B) {
	// Benchmark tests.
	for name, test := range tests {
		b.Run(name, func(b *testing.B) {
			test.Bench(b, Module, state.NewTestStateDB(b))
		})
	}
}
